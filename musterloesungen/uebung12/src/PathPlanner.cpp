#include <iostream>
#include <map>
#include <math.h>
#include <string>

#include "PathPlanner.hpp"

namespace jumper
{



/***
 * Euclidean Distance Heuristic for the A*-Search
 */
template <class MutableGraph, class CostType>
class distance_heuristic : public astar_heuristic<MutableGraph, CostType> {
public:
    typedef typename graph_traits<MutableGraph>::vertex_descriptor Vertex;

    /***
     * Constructor.
     * @param locations		The array with a position for each vertex index
     * @param goal 			A vertex descriptor (index)
     */
    distance_heuristic(Vector2f* locations, Vertex goal) : m_locations(locations), m_goal(goal) {}

    /***
     * Function operator for heuristic evaluation. Here we
     * return the Euclidean distance between current vertex
     * and goal vertex.
     *
     * @param 	u 	The currently examined vertex
     * @return 		The Euclidean distance to the goal position
     */
    CostType operator()(Vertex u)
    {
    	CostType dx = m_locations[m_goal].x() - m_locations[u].x();
    	CostType dy = m_locations[m_goal].y() - m_locations[u].y();
    	return sqrt(dx * dx + dy * dy );
    }

private:

    /// The position array accessed by vertex index
    Vector2f* 		m_locations;

    /// The index of the goal vertex
    Vertex 			m_goal;
};

/**
 * Exception for Termination of A*-Search if Goal found
 */
struct found_goal {};

/**
 * Visitor that terminates when Goal found
 */
template <class Vertex>
class astar_goal_visitor : public default_astar_visitor {
public:
    astar_goal_visitor(Vertex goal) : m_goal(goal) {}
    template <class MutableGraph>
    void examine_vertex(Vertex u, MutableGraph& g) {
        if(u == m_goal) {
            throw found_goal();
        }
    }
private:
    Vertex m_goal;
};

void PathPlanner::planPath(int s, int e)
{
	// Clear last solution
    m_solutionpath.clear();

    // Set start and target vertex
    VertexDescriptor start = s;
    VertexDescriptor goal = e;

    // Initialize predecessor map with number of vertices in
    // the graph (the maximum path can not be more than the
    // number of vertices).
    vector<VertexDescriptor> p(num_vertices(m_graph));

    // A vector with cost values to store the costs for each
    // entry in the path (i. e., costs between two vertices
    // in the found solution)
    vector<CostT> d(num_vertices(m_graph));

    // Perform A* search on the graph with our astar_goal_visitor
    try
    {

        // Call A* named Parameter Interface with our graph and
    	// start vertex. The goal vertex is used by the distance
    	// heuristic and the visitor. The first class determines
    	// the euclidean distance to the the goal (distance heuristic),
    	// the custom visitor throws an exception when the goal
    	// node is expanded.
        astar_search(
        		m_graph,
				start,
				distance_heuristic<MutableGraph, CostT>(m_nodes, goal),
				predecessor_map(&p[0]).distance_map(&d[0]).visitor(astar_goal_visitor<VertexDescriptor>(goal)));

        // Give a warning if no path from start to goal was found
        cout << endl << "No Path found." << endl << endl;

    }
    catch(found_goal fg)
    {

        // If the search reached to goal vertex, we use
    	// the predecessor map generated by the predecessor recorder
    	// to restore the path from the start vertex to the
    	// goal vertex. p[v] accesses to predecessor of v. So we
    	// push the vertices in inverse order into the target list
    	// until we reached the start (which has no predecessor, hence
    	// p[v] = v.
        list<VertexDescriptor> shortest_path;
        for(VertexDescriptor v = goal;; v = p[v])
        {
            shortest_path.push_front(v);
            if(p[v] == v)
            {
                break;
            }
        }

        // Get an iterator to the first vertex in the goal path
        list<VertexDescriptor>::iterator spi = shortest_path.begin();

        // Now we know the vertex order, but we want to store the
        // real vertex coordinates of the nodes. So we have to
        // iterate through the path, get the vertex indices and
        // save the coordinates from the node array in the solution
        for(; spi != shortest_path.end(); ++spi)
        {
            float x = m_nodes[*spi].x();
            float y = m_nodes[*spi].y();

            m_solutionpath.push_back(Vector2f (x, y));
            cout << *spi << " " << " (" << x << ", " << y << ") " << endl;
        }
    }
}


PathPlanner::PathPlanner (Network* net)
{
	// Get vertices and edges from network
	const vector<Vector2i>& n_nodes = net->getNodes();
	const vector<pair<unsigned int, unsigned int> >& edges = net->getEdges();
	size_t nodecount = n_nodes.size();

	// Initialize graph structure
    m_graph = MutableGraph(nodecount);

    // Generate an array for the node positions. Since
    // BGL uses vertex indices and weights, we have to store
    // the position information for each vertex separately.
    m_nodes = new Vector2f[nodecount];
    for(size_t i = 0; i < nodecount; i++)
    {
    	m_nodes[i].setX(n_nodes[i].x());
    	m_nodes[i].setY(n_nodes[i].y());
    }

    // Generate edge descriptors and add the to the graph.
    // The edges weights in this example is the Euclidean
    // distace between the two edge vertices.
    for(size_t i = 0; i < edges.size(); i++)
    {
        EdgeDescriptor e;
        bool inserted;
        int from = edges[i].first;
        int to = edges[i].second;
        tie(e, inserted) = add_edge(from, to, m_graph);
        m_weightmap[e] = m_nodes[from].distanceTo(m_nodes[to]);
    }

  
}
    
}
